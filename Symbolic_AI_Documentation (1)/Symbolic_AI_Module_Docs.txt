
SYMBOLIC AI MODULE DOCUMENTATION
================================

ğŸ“¦ SpoonEngine
- Purpose: Tracks symbolic task energy levels
- Key Methods: apply(), restore(), status()

ğŸ“„ PDFDigestor
- Purpose: Converts PDF files into YAML memory fragments
- Output Path: D:/Project_AI/fragments/pdf/

ğŸ§  QuantumMemory
- Purpose: Stores key-value pairs encoded with quantum statevectors
- Depends on: Qiskit, PlasmaClient

âš›ï¸ fractal_attention()
- Purpose: Accelerated attention mechanism
- Depends on: flash_attention, numpy

ğŸ” SecureMemory
- Purpose: Atomic write access to memory map
- Method: atomic_write(data, offset)

ğŸ“¤ NeuroStoreManager
- Purpose: Handles fragment injection into DuckDB
- Output DBs: D:/Project_AI/memory_db/*.duckdb

ğŸ’¾ SymbolicQueryCache
- Purpose: Caches query results for fast recall
- Output: query_cache.json

ğŸ“Š FragmentTagGraph
- Purpose: Analyzes tag usage across memory DBs
- Output: meta/tag_graph.png

ğŸ§  NIMHarness
- Purpose: Modular LLM dispatcher
- Usage: register_model(), call()

ğŸ§ª QuantumETL
- Purpose: Encodes symbolic text into quantum states

ğŸ­ AvatarEngineShell
- Purpose: Injects and executes modular expression scripts

ğŸ“ˆ ModelStatProfiler
- Purpose: Profiles model inference latency

ğŸ’“ EmotionEngine
- Purpose: Tracks valence, arousal, and saturation

ğŸ§© ModuleToggleRegistry
- Purpose: Turns modules ON/OFF at runtime or via GUI

ğŸ“‚ GUI Dashboard (Black Dashboard Django)
- Panel Left: agent toggles, emotion engine, LLM slots
- Panel Right: RAM stats, log stream, DB fragment count

